<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>obj_xyz</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>604</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_inherited</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>dir=1;
vspd=0;
z_rest=0;
ground_rest=noone;
on_ground=false;

stat_recharge_delay=190;
stat_recharge_rate=0;
stat_maxhp=20;
hp=stat_maxhp
hp_bardrain=0;
//how blocking affects damage
stat_blk_mult=0;
stat_blk_sub=0;
//how blocking affects knockback
stat_blk_knock_mult=0;
stat_blk_knock_sub=0;
//speed
stat_spd=4;
stat_blkspd=2;
stat_run=10;
stat_hitdrift=2; //speed at which player moves back while in hitstun
//jumping
stat_grav=-3;
stat_jumpspd=20;
stat_jumpspd_blk=15;
//knockback:
stat_knockback_friction_ground=4;
stat_knockback_friction_air=1;

move_x=0;
move_y=0
do_jump=false;
do_zhalt=false
do_run=false;
do_block=false;
is_blocking=false;
extra_action=0;
do_dir=0;

faction=0
bounce_sub=20;
bounce_max=60;
bounce_mult=0;

t_since_hit=-1;
t_since_jump=-1;

dim_w=20;
dim_h=10;
dim_z=10;

c_hp_gone=make_color_hsv(15,132,156)
a_hp_gone=0.6;
c_hp_gone_dire=c_hp_gone;
a_hp_gone_dire=a_hp_gone;
c_hp_full=make_color_hsv(13,90,220)
a_hp_full=0.8;
c_hp_drain=c_red;
a_hp_drain=1;
spr_hp_ring_loc = spr_hp_ring_med

//player controlling this
player = PL_NOPLAYER;
p_mode = P_AUTOMATIC;

shadow=noone;
spr_shadow_loc=spr_shadow_med;
obj_explosion_loc=obj_explosion;

image_speed=0;

//the attack that holds the lock on further attacking this frame
attack_lock=0;

//if &gt; 0, prevents moving, etc.
t_hit_stun=0;

knockback_vx=0;
knockback_vy=0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>z detection</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var retval = find_z_rest(x-dim_w/2,y-dim_h/2,x+dim_w/2,y+dim_h/2,z);

ground_rest=retval[0];
z_rest=retval[1];
on_ground=retval[2];
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>shadow</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (!instance_exists(shadow)) {
    shadow = instance_create(x,y,obj_shadow)
    shadow.parent=id;
    shadow.sprite_index=spr_shadow_loc;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>possessor overide</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>601</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>1</exetype>
        <functionname>action_execute_script</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>9</kind>
            <script>possess_control</script>
          </argument>
          <argument>
            <kind>0</kind>
            <string></string>
          </argument>
          <argument>
            <kind>0</kind>
            <string></string>
          </argument>
          <argument>
            <kind>0</kind>
            <string></string>
          </argument>
          <argument>
            <kind>0</kind>
            <string></string>
          </argument>
          <argument>
            <kind>0</kind>
            <string></string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>physics update</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//input variables:
//move_x: -1:1
//move_y -1:1
//do_block {0,1}
//do_jump {0,1}
//do_run {0,1}
//do_zhalt {0,1}
//do_dir {-1,0,1}

//output:
//phys_bounced
//phys_jumped
//phys_xdiff
//phys_ydiff
//phys_moved_dist
//is_blocking

//output timers:
//t_since_hit

if (t_hit_stun&gt;0)
    t_hit_stun--;

//combat mechanics
if (hp&lt;=0&amp;&amp;t_since_hit&gt;3) {
    kill(this);
}
else if (t_since_hit&gt;=stat_recharge_delay)
    heal(self,stat_recharge_rate);
if (z&lt;-2500) {
    var defn;
    defn[0]=0;
    defn[4]=true;
    wound(this,-1,defn)
}

//hp bardrain:
if (t_since_hit&gt;=5||t_since_hit==-1) {
    hp_bardrain-=0.6;
}
hp_bardrain=max(hp,hp_bardrain);

is_blocking=do_block;

//report flags:
phys_bounced=false;
phys_jumped=false;

if (t_since_jump&gt;=0)
    t_since_jump++;

//z movement
if (!is_hit_stunned()) {
    if (can_act()&amp;&amp;do_jump&amp;&amp;on_ground) {
        t_since_jumped=0;
        if (!is_blocking) vspd=stat_jumpspd;
        else vspd=stat_jumpspd_blk;
    }
    
    if (!on_ground)
        vspd+=stat_grav;
        
    if (can_act()&amp;&amp;do_zhalt&amp;&amp;vspd&gt;0)
        vspd=0;
    
    z+= vspd;
    if (z&lt;z_rest) {
        z=z_rest
        vspd*=-bounce_mult;
        vspd-=bounce_sub
        if (vspd&gt;bounce_max&amp;&amp;bounce_max&gt;0)
            vspd=bounce_max;
        if (vspd&lt;0)
            vspd=0;
    }
}

//x-y movement
if (room_properties.sideview)
    move_y=0;
var xorig=x;
var yorig=y;
var xspd = stat_spd;
var yspd = stat_spd;
if (do_run) {xspd=stat_run;yspd/=2}
if (do_block) {xspd=stat_blkspd; yspd=stat_blkspd;}
phys_xdiff=0;
phys_ydiff=0;
if can_act() {
    phys_xdiff = move_x*xspd;
    phys_ydiff = move_y*yspd;
}

if (is_hit_stunned()&amp;&amp;abs(knockback_vx)+abs(knockback_vy)&lt;5) {
    //knockback if hitstunned -- but not if about to be knocked back
    phys_xdiff=-dir*stat_hitdrift;
}

if (!is_hit_stunned()) {
    //knockback stuff:
    phys_xdiff+=knockback_vx;
    phys_ydiff+=knockback_vy
    
    //friction for knockback:
    var knockback_friction = stat_knockback_friction_air;
    if (on_ground)
        knockback_friction=stat_knockback_friction_ground;
    
    //friction for knockback (x):
    sign_knockback_vx=sign(knockback_vx);
    knockback_vx-=sign_knockback_vx*knockback_friction;
    if (knockback_vx*sign_knockback_vx&lt;=0)
        knockback_vx=0;
        
    //friction for knockback (y):
    sign_knockback_vy=sign(knockback_vy);
    knockback_vy-=sign_knockback_vy*knockback_friction;
    if (knockback_vy*sign_knockback_vy&lt;=0)
        knockback_vy=0;
}
    
//what follows is some very messy movement script...

var grounds_xn = get_grounds_in(xorig+phys_xdiff-dim_w/2,yorig-dim_h/2,xorig+phys_xdiff+dim_w/2,yorig+dim_h/2)

z_allowance=point_distance(0,0,phys_xdiff,phys_ydiff)+0.5;
if (room_properties.bumpy)
    z_allowance+=4;

var zdiff=z_allowance
var collision=false;

for (var i=0;grounds_xn[i]!=noone;i++) {
    //collision!
    if (grounds_xn[i].z&gt;z+zdiff&amp;&amp;grounds_xn[i].zbot&lt;=z+zdiff) {
        zdiff=0;
        collision=true;
    }
}

if (collision) {
    //try again without slope
    collision=false;
    for (var i=0;grounds_xn[i]!=noone;i++) {
        //collision!
        if (grounds_xn[i].z&gt;z+zdiff&amp;&amp;grounds_xn[i].zbot&lt;=z+zdiff) {
            phys_xdiff=0;
            collision=true;
        }
    }
}

x+=phys_xdiff;

var grounds_yn = get_grounds_in(xorig-dim_w/2,yorig-dim_h/2+phys_ydiff,xorig+dim_w/2,yorig+dim_h/2+phys_ydiff)
for (var i=0;grounds_yn[i]!=noone;i++) {
    //collision!
    if (grounds_yn[i].z&gt;z+zdiff&amp;&amp;grounds_yn[i].zbot&lt;=z+zdiff) {
        phys_ydiff=0;
    }
}

y+=phys_ydiff;
z+=zdiff;
if (zdiff!=0) {
    var z_rest_alt = find_z_rest(x-dim_w/2,y-dim_h/2,x+dim_z/2,y+dim_h/2,z);
    if abs(z-z_rest_alt[1])&lt;=2*z_allowance {
        z=z_rest_alt[1];
        on_ground=true;
    } else
        z-=zdiff;
}
phys_moved_dist = point_distance(0,0,phys_xdiff,phys_ydiff);

//update facing:
if (!do_block) {
    if (move_x&lt;0)
        dir=-1;
    if (move_x&gt;0)
        dir=1;
}

if(can_act()&amp;&amp;do_dir!=0)
    dir=sign(do_dir);

//timers:
if (t_since_hit&gt;=0)
    t_since_hit++;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="73">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (hp&lt;stat_maxhp) {
    var cx=get_draw_x()
    var cy=get_draw_y()-dim_z/2;
    var ring_w = sprite_get_width(spr_hp_ring_loc);
    var ring_h = sprite_get_height(spr_hp_ring_loc);
    var ring_scale = 1;
    var alph_mult=1;
    if (t_since_hit&gt;400) {
        alph_mult=1-(t_since_hit-400)/100
        if (alph_mult&lt;0.2)
            alph_mult=0.2;
    }
    if (t_since_hit&gt;=0&amp;&amp;t_since_hit&lt;4){
        ring_scale=t_since_hit*0.2/4+0.8;
        ring_scale=sqrt(ring_scale)
    }
    //draw background wheel:
    var merge_colour_amount=hp/stat_maxhp*3.7-0.8
    merge_colour_amount=max(0,min(merge_colour_amount,1))
    var merge_alpha=a_hp_gone_dire*merge_colour_amount+a_hp_gone*(1-merge_colour_amount)
    var c_hp_gone_tmp=merge_colour(c_hp_gone_dire,c_hp_gone,merge_colour_amount)
    
    //background wheel:
    draw_wheel(cx,cy,spr_hp_ring_loc,0,1,ring_scale,c_hp_gone_tmp,merge_alpha*alph_mult)
    
    //hp remaining wheel:
    draw_wheel(cx,cy,spr_hp_ring_loc,0,hp/stat_maxhp,ring_scale,c_hp_full,a_hp_full*alph_mult)
    
    if (hp_bardrain&gt;hp)
    //hp drain wheel:
    draw_wheel(cx,cy,spr_hp_ring_loc,hp/stat_maxhp,hp_bardrain/stat_maxhp,ring_scale,c_hp_drain,a_hp_drain*alph_mult)
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>image_xscale=dir
draw_set_alpha(1);
if (t_since_hit&gt;=0&amp;&amp;t_since_hit&lt;6) {
    image_blend=c_red;
} else
    image_blend=c_white;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>604</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_inherited</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
