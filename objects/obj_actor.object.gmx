<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>obj_xyz</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>604</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_inherited</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>dir=1;
vspd=0;
z_rest=0;
ground_rest=noone;
on_ground=false;

stat_recharge_delay=190;
stat_recharge_rate=0;
stat_maxhp=20;
hp=stat_maxhp
hp_registered=0;
hp_bardrain=0;
//how blocking affects damage
stat_blk_mult=0;
stat_blk_sub=0;
//speed
stat_spd=4;
stat_blkspd=2;
stat_run=10;
stat_hitdrift=2.5; //speed at which actor moves back while in hitstun
//jumping
stat_grav=-3;
stat_jumpspd=20;
stat_jumpspd_blk=15;
//knockback:
stat_knockback_friction_ground=3;
stat_knockback_friction_air=1;
//multiplies length of hit stun
stat_hit_stun_recovery_mult=2.5;
//can recover from hit stun over time
stat_hit_stun_recovers=false;

move_x=0;
move_y=0;
move_z=0;
do_jump=false;
do_fly=false;
do_zhalt=false
do_run=false;
do_block=false;
do_atk=false;
is_blocking=false;
is_jumping=false;
extra_action=0;
do_dir=0;

faction=0
bounce_sub=20;
bounce_max=60;
bounce_mult=0;

t_since_hit=-1;
t_since_jump=-1;
t_since_attack=-1;

combo_state=0;

dim_x=20;
dim_y=20;
dim_z=20;

c_hp_gone=make_color_hsv(15,132,156)
a_hp_gone=0.6;
c_hp_gone_dire=c_hp_gone;
a_hp_gone_dire=a_hp_gone;
c_hp_full=make_color_hsv(13,90,220)
a_hp_full=0.8;
c_hp_drain=c_red;
a_hp_drain=1;
spr_hp_ring_loc = spr_hp_ring_med

//player controlling this
player = PL_NOPLAYER;
p_mode = P_AUTOMATIC;
possessor_instance=noone;
possessor_port=0;

shadow=noone;
spr_shadow_loc=spr_shadow_med;
obj_explosion_loc=obj_explosion;

image_speed=0;

//the attack that holds the lock on further attacking this frame
attack_lock=0;

//if &gt; 0, prevents moving, etc.
t_hit_stun=0;
//histry of times hit-stunned before being able to act
hit_stun_counter=0;
//completely freezes actor briefly when hit.
t_hit_freeze=0;
//set to true when t_hit_freeze reaches 0
hit_stun_registered=false;
//certain attacks make this briefly false:
action_queue_release=false;
can_move=true;
can_dir=true;
can_act_misc=true;
//certain attacks make these briefly non-zero:
propulsion_x=0;
propulsion_y=0;

knockback_vx=0;
knockback_vy=0;

loc_sfx_on_hit=sfx_hit;
loc_sfx_on_block=sfx_ping;
loc_sfx_on_death=sfx_explosion;

AN_idle = make_animation(0,1,1);
AN_walk = make_animation(0,1,1);
AN_run = AN_walk;
AN_fly = AN_walk;
AN_jump_up = make_animation(0,1,1);
AN_jump_down = make_animation(0,1,1);
AN_jump_land = make_animation(0,1,1);
AN_block = make_animation(0,1,1);
AN_hitstun = make_animation(0,1,1);
AN_death = AN_hitstun;
AN_extra[0]=make_animation(0,1,1);
AN_attack=AN_idle

anim=0;
anim_move=0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>z detection</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var retval = find_z_rest(x-dim_x/2,y-dim_y/2,x+dim_x/2,y+dim_y/2,z);

ground_rest=retval[0];
z_rest=retval[1];
on_ground=retval[2]*(vspd&lt;=0);
if (on_ground)
    is_jumping=false;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>shadow</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (!instance_exists(shadow)) {
    shadow = instance_create(x,y,obj_shadow)
    shadow.parent=id;
    shadow.sprite_index=spr_shadow_loc;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>hit stun timer</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>action_queue_release=false;
if (t_hit_stun&gt;0 &amp;&amp; !is_hit_frozen()) {
    t_hit_stun--;
    hit_stun_registered=true;
    if t_hit_stun==0 {
        hit_stun_registered=false;
        //stop queueing actions 
        action_queue_release=true;
    }
} 
if (t_hit_stun&lt;=0)
    hit_stun_registered=false;

if (t_hit_freeze&gt;0 ) {
    t_hit_freeze--;
    if (t_hit_freeze==0&amp;&amp;t_hit_stun&gt;0)
        hit_stun_registered=true;
}

if (t_since_hit&gt;=0&amp;&amp;!is_hit_frozen())
    t_since_hit++;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>possessor overide</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>601</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>1</exetype>
        <functionname>action_execute_script</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>9</kind>
            <script>possess_control</script>
          </argument>
          <argument>
            <kind>0</kind>
            <string></string>
          </argument>
          <argument>
            <kind>0</kind>
            <string></string>
          </argument>
          <argument>
            <kind>0</kind>
            <string></string>
          </argument>
          <argument>
            <kind>0</kind>
            <string></string>
          </argument>
          <argument>
            <kind>0</kind>
            <string></string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>physics update</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//input variables:
//move_x: -1:1
//move_y -1:1
//move_z -1:1
//do_fly {0,1}
//do_block {0,1}
//do_jump {0,1}
//do_run {0,1}
//do_zhalt {0,1}
//do_dir {-1,0,1}

//output:
//phys_bounced
//phys_jumped
//phys_xdiff
//phys_ydiff
//phys_moved_dist
//is_blocking

//output timers:
//t_since_hit
//t_since_jump

//hitstun and hitfreeze timers updated in begin step for symmetry
    
var knockback_xdiff=0
var knockback_ydiff=0;

if (is_flying())
    on_ground=false;
    
if (!can_move)
    //don't allow the player to block if they are also unable to move
    //(because some attacks prevent moving while in use)
    do_block=false;
if (can_act())
    is_blocking=do_block;
    
if (!is_hit_frozen()) {
    //knockback stuff:
    knockback_xdiff=knockback_vx;
    knockback_ydiff=knockback_vy
    
    //friction for knockback:
    var knockback_friction = stat_knockback_friction_air;
    if (on_ground)
        knockback_friction=stat_knockback_friction_ground;
    
    //friction for knockback (x):
    sign_knockback_vx=sign(knockback_vx);
    knockback_vx-=sign_knockback_vx*knockback_friction;
    if (knockback_vx*sign_knockback_vx&lt;=0)
        knockback_vx=0;
        
    //friction for knockback (y):
    sign_knockback_vy=sign(knockback_vy);
    knockback_vy-=sign_knockback_vy*knockback_friction;
    if (knockback_vy*sign_knockback_vy&lt;=0)
        knockback_vy=0;
    
    //gravity
    if (abs(knockback_vx)&gt;stat_hitdrift||!is_hit_stunned()) {
        if (!on_ground&amp;&amp;!is_flying())
            vspd+=stat_grav;
        if (is_flying()) {
            //if fly
            sign_vspd=sign(vspd);
            vspd-=sign_vspd*knockback_friction;
            if (vspd*sign_vspd&lt;=0) {
                vspd=0;
                is_jumping=false;
            }
        }
    }
}

//combat mechanics
if (hp&lt;=0&amp;&amp;t_since_hit&gt;3&amp;&amp;!is_hit_frozen()) {
    kill(this);
}
else if (t_since_hit&gt;=stat_recharge_delay)
    heal(self,stat_recharge_rate);
if (!is_hit_frozen())
    hp_registered=hp;
if (z&lt;room_properties.bottom) {
    var defn;
    defn[0]=0;
    defn[4]=true;
    defn[6]=true;
    wound(this,-1,defn)
}

//hp bardrain:
if (t_since_hit&gt;=5||t_since_hit==-1) {
    hp_bardrain-=0.6;
}
hp_bardrain=max(hp,hp_bardrain);
    
//hit-stun-counter reset:
if (can_act())
    hit_stun_counter=0;

//report flags:
phys_bounced=false;
phys_jumped=false;

if (t_since_jump&gt;=0 &amp;&amp; !is_hit_frozen())
    t_since_jump++;

//jumping
if (can_act()&amp;&amp;do_jump&amp;&amp;on_ground) {
        t_since_jump=0;
        is_jumping=true;
        if (!is_blocking) vspd=stat_jumpspd;
        else vspd=stat_jumpspd_blk;
    }

if (can_act()&amp;&amp;do_zhalt&amp;&amp;vspd&gt;0&amp;&amp;is_jumping)
        vspd=0;

//x-y movement
if (room_properties.sideview)
    move_y=0;
var xorig=x;
var yorig=y;
var xspd = stat_spd;
var yspd = stat_spd;
var zspd = stat_spd;
if (do_run&amp;&amp;!room_properties.no_running) {xspd=stat_run;yspd/=2}
if (is_blocking) {xspd=stat_blkspd; yspd=stat_blkspd; zspd=stat_blkspd;}
phys_xdiff=0;
phys_ydiff=0;
phys_zdiff=0;
if can_act() &amp;&amp; can_move {
    phys_xdiff = move_x*xspd;
    phys_ydiff = move_y*yspd;
    phys_zdiff = move_z*zspd*is_flying();
}

if (is_hit_stunned()&amp;&amp;abs(knockback_vx)&lt;=stat_hitdrift) {
    //drift if hitstunned
    phys_xdiff=-dir*stat_hitdrift;
} else {
    //propulsion from attacks:
    phys_xdiff+=propulsion_x
}
if (is_hit_frozen())
    phys_xdiff=0;

phys_xdiff+=knockback_xdiff;
phys_ydiff+=knockback_ydiff;
phys_zdiff+=vspd*(!is_hit_stunned()||abs(knockback_vx)&gt;stat_hitdrift)*!is_hit_frozen();

//do actual movement
move(phys_xdiff,phys_ydiff,phys_zdiff,2,ground_rest);

//bounce:
if (collision_z!=noone &amp;&amp; vspd&lt;0) {
    is_jumping=false;
    vspd*=-bounce_mult;
    vspd-=bounce_sub
    if (vspd&gt;bounce_max&amp;&amp;bounce_max&gt;0)
        vspd=bounce_max;
    if (vspd&lt;0)
        vspd=0;
}

phys_moved_dist = point_distance(0,0,phys_xdiff,phys_ydiff);

//update facing:
if (!is_blocking &amp;&amp; can_dir &amp;&amp; can_act()) {
    if (move_x&lt;0)
        dir=-1;
    if (move_x&gt;0)
        dir=1;
}

if(can_act()&amp;&amp;can_dir&amp;&amp;do_dir!=0)
    dir=sign(do_dir);
    
//attacks:
if (!is_hit_stunned()&amp;&amp;!is_hit_frozen()&amp;&amp;t_since_attack&gt;=0)
    t_since_attack++;

//display hitbox:
if (config.RENDER_HITBOX_ENABLED) {
    var n = obj_gui.hitbox_draw_n++;
    obj_gui.hitbox_draw_x[n]=x-dim_x/2
    obj_gui.hitbox_draw_y[n]=y-dim_y/2
    obj_gui.hitbox_draw_z[n]=z
    
    obj_gui.hitbox_draw_w[n]=dim_x
    obj_gui.hitbox_draw_h[n]=dim_y
    obj_gui.hitbox_draw_zh[n]=dim_z
    
    obj_gui.hitbox_draw_alpha[n]=0.2;
    var col=c_white;
    if (is_hit_frozen())
        col=c_orange;
    if (is_hit_stunned())
        col = c_red;
    obj_gui.hitbox_draw_colour[n]=col;
    
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="73">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var cx = get_draw_x();
var cy = get_draw_y()-dim_z/2;
var _hp=hp;
if (is_hit_frozen())
    _hp = hp_registered;

if (_hp&lt;stat_maxhp &amp;&amp; player == PL_NOPLAYER) {
    var ring_w = sprite_get_width(spr_hp_ring_loc);
    var ring_h = sprite_get_height(spr_hp_ring_loc);
    var ring_scale = 1;
    var alph_mult=1;
    if (t_since_hit&gt;400) {
        alph_mult=1-(t_since_hit-400)/100
        if (alph_mult&lt;0.2)
            alph_mult=0.2;
    }
    if (t_since_hit&gt;=0&amp;&amp;t_since_hit&lt;4 &amp;&amp; !is_hit_frozen()){
        ring_scale=t_since_hit*0.2/4+0.8;
        ring_scale=sqrt(ring_scale)
    }
    //draw background wheel:
    var merge_colour_amount=_hp/stat_maxhp*3.7-0.8
    merge_colour_amount=max(0,min(merge_colour_amount,1))
    var merge_alpha=a_hp_gone_dire*merge_colour_amount+a_hp_gone*(1-merge_colour_amount)
    var c_hp_gone_tmp=merge_colour(c_hp_gone_dire,c_hp_gone,merge_colour_amount)
    
    //background wheel:
    draw_wheel(cx,cy,spr_hp_ring_loc,0,1,ring_scale,c_hp_gone_tmp,merge_alpha*alph_mult)
    
    //hp remaining wheel:
    draw_wheel(cx,cy,spr_hp_ring_loc,0,hp/stat_maxhp,ring_scale,c_hp_full,a_hp_full*alph_mult)
    
    if (hp_bardrain&gt;_hp)
    //hp drain wheel:
    draw_wheel(cx,cy,spr_hp_ring_loc,_hp/stat_maxhp,hp_bardrain/stat_maxhp,ring_scale,c_hp_drain,a_hp_drain*alph_mult)
}

//off-screen bubbles
if (player&gt;=0)
    if (cx&lt;view_xview[0]-32||cx &gt; view_xview[0]+view_wview[0]+32) {
        var bubble_dir = sign(cx-camera.x);
        var bubble_r_large = 64;
        var bubble_r_med = 52;
        var bubble_r_small = 48;
        var bubble_cx = max(min(cx,view_xview[0]+view_wview[0]-bubble_r_large),view_xview[0]+bubble_r_large)
        var bubble_cy = max(min(cy,view_yview[0]+view_hview[0]-bubble_r_large),view_yview[0]+bubble_r_large)
        draw_set_color(get_player_color(player));
        draw_set_alpha(1);
        draw_circle(bubble_cx,bubble_cy,bubble_r_med,false)
        draw_sprite_ext(spr_bubble_pointer,0,bubble_cx,bubble_cy,1,1,point_direction(bubble_cx,bubble_cy,cx,cy),get_player_color(player),1)
        draw_set_color(c_ltgray)
        draw_circle(bubble_cx,bubble_cy,bubble_r_small,false)
        draw_sprite_ext(sprite_index,image_index,bubble_cx,bubble_cy+dim_z/2,image_xscale,image_yscale,0,c_white,1);
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>image_xscale=dir
draw_set_alpha(1);
if (hit_stun_registered) {
    image_blend=c_red;
} else
    image_blend=c_white;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>604</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_inherited</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
